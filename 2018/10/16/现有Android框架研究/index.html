<!DOCTYPE html>
<html>
<head>
    

    
<!-- Tencent Speed -->
<script>var _speedMark = new Date()</script>
<!-- End Tencent Speed -->
<!-- Tencent Analysis -->
<script async src="//tajs.qq.com/stats?sId=61021328"></script>
<!-- End Tencent Analysis -->


    



    <meta charset="utf-8">
    
    
    
    <title>现有Android框架研究 | ViVi&#39;s craft | 只用来写技术相关的文章，记一些平时很少用很容易忘记的东西。能用实际项目来掌握的技术还懒得写，于是很少更新。想看更新频繁,内容日常的博客，请移步：&lt;a style=&#34;color:#FFFFFF;&#34; herf=&#34;https://chenvivi.wordpress.com&#34;&gt;https://chenvivi.wordpress.com&lt;/a&gt;</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Android">
    <meta name="description" content="第一天 (2018/10/15)简述基本上大家都知道 Google 有 android-architecture，看了看简介发现是一种教程性质的东西并不是具体框架。然后我自己知道有 iosched，每年 Google 大会的新内容都会在里边呈现。还有一个 Android-CleanArchitecture，然而项目都还是基于 Android Studio 2.0 的无法直接运行，于是先看了 ios">
<meta name="keywords" content="Android">
<meta property="og:type" content="article">
<meta property="og:title" content="现有Android框架研究">
<meta property="og:url" content="http://blog.valorachen.club/2018/10/16/现有Android框架研究/index.html">
<meta property="og:site_name" content="ViVi&#39;s craft">
<meta property="og:description" content="第一天 (2018/10/15)简述基本上大家都知道 Google 有 android-architecture，看了看简介发现是一种教程性质的东西并不是具体框架。然后我自己知道有 iosched，每年 Google 大会的新内容都会在里边呈现。还有一个 Android-CleanArchitecture，然而项目都还是基于 Android Studio 2.0 的无法直接运行，于是先看了 ios">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/9/26/23d6420c87d5f7edeafc1ea28ad11b6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/9/26/bd56e25dd49bd435f362f2ce4e154ea5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/9/26/f30d09f9cd370252bc93eef5ae94e6e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/9/26/fb77688ba420944b34e82b0b6ef20a07?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/9/26/857316692be156e8bd2d0779fbdd9847?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2017/9/26/ada08d38bad75868981d15d007a7c9fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:updated_time" content="2018-10-18T03:51:00.043Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="现有Android框架研究">
<meta name="twitter:description" content="第一天 (2018/10/15)简述基本上大家都知道 Google 有 android-architecture，看了看简介发现是一种教程性质的东西并不是具体框架。然后我自己知道有 iosched，每年 Google 大会的新内容都会在里边呈现。还有一个 Android-CleanArchitecture，然而项目都还是基于 Android Studio 2.0 的无法直接运行，于是先看了 ios">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2017/9/26/23d6420c87d5f7edeafc1ea28ad11b6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
    
        <link rel="alternate" type="application/atom+xml" title="ViVi&#39;s craft" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">ViVi</h5>
          <a href="mailto:valorachen@163.com" title="valorachen@163.com" class="mail">valorachen@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                时间线
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://chenvivi.wordpress.com/" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                我的日记（代替py圈）
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/atom.xml" target="_blank" >
                <i class="icon icon-lg icon-rss"></i>
                RSS
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/ChenViVi" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://steamcommunity.com/profiles/76561198300793241" target="_blank" >
                <i class="icon icon-lg icon-steam"></i>
                Steam
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="http://weibo.com/p/1005053101937447/home?from=page_100505&mod=TAB&is_all=1#place" target="_blank" >
                <i class="icon icon-lg icon-weibo"></i>
                微博
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">现有Android框架研究</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">现有Android框架研究</h1>
        <h5 class="subtitle">
            
                <time datetime="2018-10-16T06:09:11.000Z" itemprop="datePublished" class="page-time">
  2018-10-16
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第一天-2018-10-15"><span class="post-toc-number">1.</span> <span class="post-toc-text">第一天 (2018/10/15)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简述"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">简述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#详细过程"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">详细过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结论"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">结论</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第二天-2018-10-16"><span class="post-toc-number">2.</span> <span class="post-toc-text">第二天(2018/10/16)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简述-1"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">简述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#详细过程-1"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">详细过程</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#结论-1"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">结论</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第三天-2018-10-17"><span class="post-toc-number">3.</span> <span class="post-toc-text">第三天(2018/10/17)</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#第四天-2018-10-18"><span class="post-toc-number">4.</span> <span class="post-toc-text">第四天(2018/10/18)</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#简述-2"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">简述</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Room-框架"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Room 框架</span></a></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-现有Android框架研究"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">现有Android框架研究</h1>
        <div class="post-meta">
            <time class="post-time" title="2018-10-16 14:09:11" datetime="2018-10-16T06:09:11.000Z"  itemprop="datePublished">2018-10-16</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="第一天-2018-10-15"><a href="#第一天-2018-10-15" class="headerlink" title="第一天 (2018/10/15)"></a>第一天 (2018/10/15)</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>基本上大家都知道 Google 有 <a href="https://github.com/googlesamples/android-architecture?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">android-architecture</a>，看了看简介发现是一种教程性质的东西并不是具体框架。然后我自己知道有 <a href="https://github.com/google/iosched?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">iosched</a>，每年 Google 大会的新内容都会在里边呈现。还有一个 <a href="https://github.com/android10/Android-CleanArchitecture?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">Android-CleanArchitecture</a>，然而项目都还是基于 Android Studio 2.0 的无法直接运行，于是先看了 iosched</p>
<h3 id="详细过程"><a href="#详细过程" class="headerlink" title="详细过程"></a>详细过程</h3><p>首先运行，发现首页上有<code>开始使用</code>字样，于是去搜这个字段，发现了唯一使用这个字段的 layout 文件叫做<code>fragment_onboarding</code>，然后查看哪些地方使用了这个 layout 文件，找到了<code>FragmentOnboardingBinding</code>，<code>DataBinderMapperImpl</code></p>
<p><code>DataBinderMapperImpl</code>中有一个不熟悉的数据结构<code>SparseIntArray</code>，中存储了这个 layout 的 id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    INTERNAL_LAYOUT_ID_LOOKUP.put(com.google.samples.apps.iosched.R.layout.dialog_remove_reservation, LAYOUT_DIALOGREMOVERESERVATION);</span><br><span class="line">...</span><br><span class="line">    INTERNAL_LAYOUT_ID_LOOKUP.put(com.google.samples.apps.iosched.R.layout.fragment_map, LAYOUT_FRAGMENTMAP);</span><br><span class="line">    INTERNAL_LAYOUT_ID_LOOKUP.put(com.google.samples.apps.iosched.R.layout.fragment_onboarding, LAYOUT_FRAGMENTONBOARDING);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DataBinderMapperImpl</code> 还有一个方法，通过 layout id 来获取了 另一个奇怪的对象，假设这里 layoutId 的值是 <code>LAYOUT_FRAGMENTONBOARDING</code>，那么会返回一个 <code>FragmentOnboardingBindingImpl</code>。于是我全局搜索<code>LAYOUT_FRAGMENTONBOARDING</code>，居然没有发现外部调用的地方，惊了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public ViewDataBinding getDataBinder(DataBindingComponent component, View view, int layoutId) &#123;</span><br><span class="line">  int localizedLayoutId = INTERNAL_LAYOUT_ID_LOOKUP.get(layoutId);</span><br><span class="line">  if(localizedLayoutId &gt; 0) &#123;</span><br><span class="line">      final Object tag = view.getTag();</span><br><span class="line">      if(tag == null) &#123;</span><br><span class="line">        throw new RuntimeException(&quot;view must have a tag&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      switch(localizedLayoutId) &#123;</span><br><span class="line">      case  LAYOUT_FRAGMENTONBOARDING: &#123;</span><br><span class="line">          if (&quot;layout/fragment_onboarding_0&quot;.equals(tag)) &#123;</span><br><span class="line">            return new FragmentOnboardingBindingImpl(component, view);</span><br><span class="line">          &#125;</span><br><span class="line">          throw new IllegalArgumentException(&quot;The tag for fragment_onboarding is invalid. Received: &quot; + tag);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我找了半天，发现这是 build 目录下的东西，吐血而亡</p>
<p>那么还是根据 Manifest 启动 Activity 找，启动 Activity 叫 <code>LauncherActivity</code>，它的父类和它本身看起来并没有渲染视图，看上去是判断一下是否进入首次启动页，用了观察者模式，不知道具体在怎么操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class LauncherActivity : DaggerAppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    @Inject lateinit var viewModelFactory: ViewModelProvider.Factory</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        val viewModel: LaunchViewModel = viewModelProvider(viewModelFactory)</span><br><span class="line">        viewModel.launchDestination.observe(this, EventObserver &#123; destination -&gt;</span><br><span class="line">            when (destination) &#123;</span><br><span class="line">                MAIN_ACTIVITY -&gt; startActivity(Intent(this, MainActivity::class.java))</span><br><span class="line">                ONBOARDING -&gt; startActivity(Intent(this, OnboardingActivity::class.java))</span><br><span class="line">            &#125;.checkAllMatched</span><br><span class="line">            finish()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先不管这个，看名字就知道首次启动页是 <code>OnboardingActivity</code>，里边只是简单的设置一下全屏显示，然后把复杂的东西交给了 <code>OnboardingFragment</code>处理，然后具体的三个可滑动页面是由<code>WelcomeFragment</code>，<code>CustomizeScheduleFragment</code>，<code>CountdownFragment</code>来展示。这里一直没有找到<code>OnboardingFragment</code>渲染的 layout 文件，但我相信它是<code>fragment_onboarding</code>，但我没能看懂 onCreateView 中返回的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(&quot;ClickableViewAccessibility&quot;)</span><br><span class="line">   override fun onCreateView(</span><br><span class="line">       inflater: LayoutInflater,</span><br><span class="line">       container: ViewGroup?,</span><br><span class="line">       savedInstanceState: Bundle?</span><br><span class="line">   ): View? &#123;</span><br><span class="line">       onboardingViewModel = viewModelProvider(viewModelFactory)</span><br><span class="line"></span><br><span class="line">       binding = FragmentOnboardingBinding.inflate(inflater, container, false).apply &#123;</span><br><span class="line">           viewModel = onboardingViewModel</span><br><span class="line">           setLifecycleOwner(this@OnboardingFragment)</span><br><span class="line">           pager.adapter = OnboardingAdapter(childFragmentManager)</span><br><span class="line">           pagerPager = ViewPagerPager(pager)</span><br><span class="line">           // If user touches pager then stop auto advance</span><br><span class="line">           pager.setOnTouchListener &#123; _, _ -&gt;</span><br><span class="line">               handler.removeCallbacks(advancePager)</span><br><span class="line">               false</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       onboardingViewModel.navigateToMainActivity.observe(this, EventObserver &#123;</span><br><span class="line">           requireActivity().run &#123;</span><br><span class="line">               startActivity(Intent(this, MainActivity::class.java))</span><br><span class="line">               finish()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line"></span><br><span class="line">       return binding.root</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在<code>fragment_onboarding</code>中可以看到，点击<code>开始使用</code>按钮的时候，执行了什么方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">           android:id=&quot;@+id/get_started&quot;</span><br><span class="line">           style=&quot;@style/Widget.IOSched.RaisedButton&quot;</span><br><span class="line">           android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:onClick=&quot;@&#123;() -&gt; viewModel.getStartedClick()&#125;&quot;</span><br><span class="line">           android:text=&quot;@string/onboarding_get_started&quot;</span><br><span class="line">           app:layout_constraintBottom_toTopOf=&quot;@id/page_indicator&quot;</span><br><span class="line">           app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">           app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">           app:layout_constraintTop_toBottomOf=&quot;@id/guide_actions&quot;</span><br><span class="line">           app:layout_constraintVertical_chainStyle=&quot;spread_inside&quot; /&gt;</span><br></pre></td></tr></table></figure>
<p>查找 <code>OnboardingFragment</code> 中的ViewModel，对应的是 <code>OnboardingViewModel</code>，点击按钮时就是这里的<code>getStartedClick</code>被执行了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class OnboardingViewModel @Inject constructor(</span><br><span class="line">    private val onboardingCompleteActionUseCase: OnboardingCompleteActionUseCase</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    private val _navigateToMainActivity = MutableLiveData&lt;Event&lt;Unit&gt;&gt;()</span><br><span class="line">    val navigateToMainActivity: LiveData&lt;Event&lt;Unit&gt;&gt; = _navigateToMainActivity</span><br><span class="line"></span><br><span class="line">    fun getStartedClick() &#123;</span><br><span class="line">        onboardingCompleteActionUseCase(true)</span><br><span class="line">        _navigateToMainActivity.postValue(Event(Unit))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getStartedClick</code>方法中的第一句还好理解，<code>onboardingCompleteActionUseCase(true)</code>这个操作也就是用 <code>SharedPreference</code>记录一下是否已经启动过首次启动页，方便下次启动 App 时进行判断而已，看 <code>OnboardingCompleteActionUseCase</code>就大概能猜到</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class OnboardingCompleteActionUseCase @Inject constructor(</span><br><span class="line">    private val preferenceStorage: PreferenceStorage</span><br><span class="line">) : UseCase&lt;Boolean, Unit&gt;() &#123;</span><br><span class="line">    override fun execute(completed: Boolean) &#123;</span><br><span class="line">        preferenceStorage.onboardingCompleted = completed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于第二句<code>_navigateToMainActivity.postValue(Event(Unit))</code>，好像是用了个观察者模式来监听，这里是发送事件的地方，不知道它具体怎么发送的，先不管。然后退回去看 <code>OnboardingFragment</code> ，在里边找到了接收事件的部分，可以看到是在这里执行了打开 <code>MainActivity</code>和关闭当前 Activity 的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onboardingViewModel.navigateToMainActivity.observe(this, EventObserver &#123;</span><br><span class="line">            requireActivity().run &#123;</span><br><span class="line">                startActivity(Intent(this, MainActivity::class.java))</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>现在 <code>MainActivity</code>打开了，先不要管它，因为上面弹出了一个提示对话框，先看看这个是从哪里来的。同样的方法，全局搜索<code>自定义日程安排</code>，找到了它对应的 layout 文件 <code>dialog_schedule_hints</code>，然后再次全局搜索，找到了使用这个 layout 文件的类叫做 <code>ScheduleUiHintsDialogFragment</code>，里边的逻辑看起来很简单，点击<code>知道了</code>就执行 dismiss() 而已，但是他继承了一个叫做 <code>CustomDimDialogFragment</code>的类，然后这个类又继承了<code>AppCompatDialogFragment</code>，然后这个类又继承了<code>DialogFragment</code>。到此，继承树才走向 <code>DialogFragment</code>。这个继承链一路走过来，有很多目前不想细看的操作，值得注意的是，继承类的包名都带有<code>androidx</code>，然后我就知道有 <a href="https://developer.android.com/jetpack/androidx/" target="_blank" rel="noopener">androidx</a> 和 <a href="https://developer.android.com/jetpack/" target="_blank" rel="noopener">jetpack</a> 了。先不管这些东西怎么用，先回到<code>ScheduleUiHintsDialogFragment</code>，既然这个对话框弹出来了，那么看看它是在哪里实例化的，然后发现了<code>ScheduleFragment</code>中的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private fun openScheduleUiHintsDialog() &#123;</span><br><span class="line">       val dialog = ScheduleUiHintsDialogFragment()</span><br><span class="line">       dialog.show(requireActivity().supportFragmentManager, DIALOG_SCHEDULE_HINTS)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法只在 <code>ScheduleFragment</code>的 onCreateView 中被这样调用。不仅如此，可以看到 onCreateView 中有大量像这样类似于观察者模式的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scheduleViewModel.scheduleUiHintsShown.observe(this, EventObserver &#123;</span><br><span class="line">           if (!it) &#123;</span><br><span class="line">               openScheduleUiHintsDialog()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br></pre></td></tr></table></figure>
<p>先不纠结<code>ScheduleFragment</code>的具体细节，回到 <code>MainActivity</code>，这里必然实例化了包括<code>ScheduleFragment</code>的三个 fragment</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        // This VM instance is shared between activity and fragments, as it&apos;s scoped to MainActivity</span><br><span class="line">        val scheduleViewModel: ScheduleViewModel = viewModelProvider(viewModelFactory)</span><br><span class="line"></span><br><span class="line">        navigation.setOnNavigationItemSelectedListener &#123;</span><br><span class="line">            when (it.itemId) &#123;</span><br><span class="line">                R.id.navigation_schedule -&gt; consume &#123; replaceFragment(ScheduleFragment()) &#125;</span><br><span class="line">                R.id.navigation_map -&gt; consume &#123;</span><br><span class="line">                    // Scroll to current event next time the schedule is opened.</span><br><span class="line">                    scheduleViewModel.userHasInteracted = false</span><br><span class="line">                    replaceFragment(MapFragment())</span><br><span class="line">                &#125;</span><br><span class="line">                R.id.navigation_info -&gt; consume &#123;</span><br><span class="line">                    // Scroll to current event next time the schedule is opened.</span><br><span class="line">                    scheduleViewModel.userHasInteracted = false</span><br><span class="line">                    replaceFragment(InfoFragment())</span><br><span class="line">                &#125;</span><br><span class="line">                else -&gt; false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Add a listener to prevent reselects from being treated as selects.</span><br><span class="line">        navigation.setOnNavigationItemReselectedListener &#123;&#125;</span><br><span class="line"></span><br><span class="line">        if (savedInstanceState == null) &#123;</span><br><span class="line">            // Show Schedule on first creation</span><br><span class="line">            navigation.selectedItemId = R.id.navigation_schedule</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Find the current fragment</span><br><span class="line">            currentFragment =</span><br><span class="line">                supportFragmentManager.findFragmentById(FRAGMENT_ID) as? MainNavigationFragment</span><br><span class="line">                ?: throw IllegalStateException(&quot;Activity recreated, but no fragment found!&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>等等，我发现这个程序在快速切换 tab 的时候居然会崩溃。天呐，作为 2018 I/O 大会的项目，居然崩溃，而且是可复现操作，惊了！看了下 log 发现并没有定位到可直接修改的代码，先不去管这个错是怎么报出来的，去 PlayStore 上下载这个App再测一遍，结果无论手速多快都没有复现 bug。再次编译并测试，很快就复现这个 bug了，可能是由于我的编译环境导致的吧，或者是 Github 上的代码并不直接对应 PlayStore 上的发行版，目前只初步想到这两种可能性。这是一个需要引起关注的点，但目前先不深究这个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">10-15 17:31:07.166 27771-27771/com.google.samples.apps.iosched E/libc: Access denied finding property &quot;vendor.perf.iop_v3.enable.debug&quot;</span><br><span class="line">    </span><br><span class="line">    --------- beginning of crash</span><br><span class="line">10-15 17:31:07.175 27771-27848/com.google.samples.apps.iosched E/AndroidRuntime: FATAL EXCEPTION: Thread-8</span><br><span class="line">    Process: com.google.samples.apps.iosched, PID: 27771</span><br><span class="line">    java.lang.NoClassDefFoundError: Failed resolution of: Lorg/apache/http/ProtocolVersion;</span><br><span class="line">        at ew.b(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):3)</span><br><span class="line">        at ev.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):3)</span><br><span class="line">        at ex.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):14)</span><br><span class="line">        at com.google.maps.api.android.lib6.drd.al.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):6)</span><br><span class="line">        at dz.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):21)</span><br><span class="line">        at dz.run(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):8)</span><br><span class="line">     Caused by: java.lang.ClassNotFoundException: Didn&apos;t find class &quot;org.apache.http.ProtocolVersion&quot; on path: DexPathList[[zip file &quot;/data/user_de/0/com.google.android.gms/app_chimera/m/00000021/MapsDynamite.apk&quot;],nativeLibraryDirectories=[/data/user_de/0/com.google.android.gms/app_chimera/m/00000021/MapsDynamite.apk!/lib/arm64-v8a, /system/lib64]]</span><br><span class="line">        at dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:169)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:379)</span><br><span class="line">        at ac.loadClass(:com.google.android.gms.dynamite_dynamiteloader@14366081@14.3.66 (100400-213742215):4)</span><br><span class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:312)</span><br><span class="line">        at ew.b(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):3) </span><br><span class="line">        at ev.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):3) </span><br><span class="line">        at ex.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):14) </span><br><span class="line">        at com.google.maps.api.android.lib6.drd.al.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):6) </span><br><span class="line">        at dz.a(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):21) </span><br><span class="line">        at dz.run(:com.google.android.gms.dynamite_mapsdynamite@14366081@14.3.66 (100400-213742215):8)</span><br></pre></td></tr></table></figure>
<p>果然还是好奇手贱，去 Issue 里搜了一下 <code>ProtocolVersion</code>，居然有人有同样的 <a href="https://github.com/google/iosched/issues/291" target="_blank" rel="noopener">issue</a>，去用如此惊人的手速点击这几个 tab 的，脑回路都有问题，居然如我一般的脑回路不正常的人类。托他的福找到了<a href="https://developers.google.com/maps/documentation/android-sdk/config#specify_requirement_for_apache_http_legacy_library" target="_blank" rel="noopener">答案</a>，经实测完美解决问题。看了一下这个项目的 target 确实是28，那么为什么不尝试一下 pr 呢？看了下这个 issue 是九月份提出来的，而那个提 issue 的 homie 并没有想到去 pr，所以 chance 就在我这里了。这个 pr 要是成功了我能吹一辈子啊~看了下最近的 pr 通过率一半都不到，也不会报太大希望，但这个问题貌似是必须要修复的 bug 应该是没有什么问题吧，再翻了翻发现每个 pr 上都有一个标识 ，<code>cla:yes</code>或者 <code>cla:no</code>，这个是 <a href="https://github.com/googlebot" target="_blank" rel="noopener">googlebot</a>自动生成的，不知道是什么高级东西。而且仔细看  <a href="https://github.com/google/iosched/pull/157" target="_blank" rel="noopener">pr</a> 发现了为 Google 贡献代码还要先同意一个<a href="https://cla.developers.google.com/clas" target="_blank" rel="noopener">条款</a>。还好我发现了，不然又白等，现在 <a href="https://github.com/google/iosched/pull/299" target="_blank" rel="noopener">我的 pr</a> 已经提了，好久没刷 Github 动态了，关注着先吧</p>
<p>今天看的代码也就一丢丢而且很多都没深究，这半天时间就过去了，感觉应该先把几个用到的框架了解一下然后再接着深入，听说 <code>Jetpack</code> 包含了 <code>androidx</code>，<code>Dragger2</code>也没深入了解过，<a href="https://github.com/android/android-ktx" target="_blank" rel="noopener">android-ktx</a> 又是个什么东西，这个项目的 ORM 是用的哪一款还没看呢</p>
<p>刚才看了一下 pr，googlebot 的审核已经过了，他们貌似在用一个高级东西做二次审核，不知道是个什么高级东西，看 <a href="https://travis-ci.org/google/iosched/builds/441594234?utm_source=github_status&amp;utm_medium=notification" target="_blank" rel="noopener">log</a> 知道是在执行 <code>gradle test</code> 命令，还可以这么搞自动审核真是高级，访问了一下这个东西的 <a href="https://travis-ci.org/" target="_blank" rel="noopener">官网</a> 感觉一脸懵逼。哎，感觉自己不知道的好东西多了去了</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>目前我没有看到我想要的东西。新框架最大的目标是减少重复工作量，可这个代码量看起来不减反增了</p>
<h2 id="第二天-2018-10-16"><a href="#第二天-2018-10-16" class="headerlink" title="第二天(2018/10/16)"></a>第二天(2018/10/16)</h2><h3 id="简述-1"><a href="#简述-1" class="headerlink" title="简述"></a>简述</h3><p>目测如果不看 Jetpack，就无法再继续阅读 iosched 了，JetPack 是 2018 I/O 大会提出的东西，也就是说这是超级新的技术</p>
<h3 id="详细过程-1"><a href="#详细过程-1" class="headerlink" title="详细过程"></a>详细过程</h3><p>去官网看 <a href="https://developer.android.google.cn/jetpack/docs/getting-started" target="_blank" rel="noopener">quick start</a> | <a href="https://github.com/Android-Jetpack-Chinese-Translation/android-jetpack-chinese-translation/blob/3418494087ed20ec2b3aeb578c90be1f281170e4/ANDROID_JETPACK/B_Get_started/1_Build_your_first_Android_Jetpack_app.md" target="_blank" rel="noopener">野生中文文档</a>，短小精悍到一脸懵逼，还好有 <a href="https://developer.android.google.cn/jetpack/docs/ComponentsBasicSample.zip" target="_blank" rel="noopener">demo 源码</a>，Manifest 中只有一个 Activity。天惹噜，这么干净的东西居然也能执行一个页面跳转逻辑，这些东西一定被隐藏在 layout 文件中了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class StartActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_start)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进 <code>activity_start</code> 中，果然发现有个新的 attribute 叫做 <code>app:navGraph=&quot;@navigation/nav_graph&quot;</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">        android:id=&quot;@+id/drawer_layout&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;fragment</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:id=&quot;@+id/my_nav_host_fragment&quot;</span><br><span class="line">        android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</span><br><span class="line">        app:navGraph=&quot;@navigation/nav_graph&quot;</span><br><span class="line">        app:defaultNavHost=&quot;true&quot;</span><br><span class="line">        /&gt;</span><br><span class="line">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>nav_graph</code> 的内容是这样的，<code>app:startDestination=&quot;@+id/launcher_home&quot;</code>规定了起始 fragment 是 <code>StartFragment</code>，然后这个 fragment 有一个 action，里边的 attribute <code>app:destination=&quot;@id/end_dest&quot;</code>规定了要跳转到的 fragment 是 <code>EndFragment</code>。可是看到这里问题就来了，采取这种方式要怎么实现两个 fragment 之间的通信呢？这个需求却是必要的，Google 不会没有想到这点的吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;navigation xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">            xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">            app:startDestination=&quot;@+id/launcher_home&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;fragment android:id=&quot;@+id/launcher_home&quot;</span><br><span class="line">              android:label=&quot;Home&quot;</span><br><span class="line">              android:name=&quot;com.android.samples.arch.componentsbasicsample.StartFragment&quot; &gt;</span><br><span class="line"></span><br><span class="line">        &lt;action android:id=&quot;@+id/end_action&quot; app:destination=&quot;@id/end_dest&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/fragment&gt;</span><br><span class="line"></span><br><span class="line">    &lt;fragment android:id=&quot;@+id/end_dest&quot;</span><br><span class="line">              android:label=&quot;End&quot;</span><br><span class="line">              android:name=&quot;com.android.samples.arch.componentsbasicsample.EndFragment&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;/fragment&gt;</span><br><span class="line">&lt;/navigation&gt;</span><br></pre></td></tr></table></figure>
<p>总之先去看 <code>StartFragment</code>吧，主要的逻辑都在 onCreateActivity 中，这个用来实例化 viewModel 的 <code>ViewModelProviders</code>目测是 Jetpack 中的。<code>view?.let { Navigation.findNavController(it).navigate(R.id.end_action) }</code>，就是点击之后执行的操作，这里执行了 <code>nav_graph</code>中 定义的 end_action</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">override fun onActivityCreated(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onActivityCreated(savedInstanceState)</span><br><span class="line">        // Obtain ViewModel from ViewModelProviders, using this fragment as LifecycleOwner.</span><br><span class="line">        viewModel = ViewModelProviders.of(this).get(StartViewModel::class.java)</span><br><span class="line"></span><br><span class="line">        // Observe data on the ViewModel, exposed as a LiveData</span><br><span class="line">        viewModel.data.observe(this, Observer &#123; data -&gt;</span><br><span class="line">            // Set the text exposed by the LiveData</span><br><span class="line">            view?.findViewById&lt;TextView&gt;(R.id.text)?.text = data</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        // Set up a click listener on the login button</span><br><span class="line">        view?.findViewById&lt;Button&gt;(R.id.navigate_bt)?.setOnClickListener &#123;</span><br><span class="line">            // Navigate to the login destination</span><br><span class="line">            view?.let &#123; Navigation.findNavController(it).navigate(R.id.end_action) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>而这个 <code>StartViewModel</code> ，只是简单的定义了一个字符串的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class StartViewModel : ViewModel() &#123;</span><br><span class="line">    private val _data = MutableLiveData&lt;String&gt;()</span><br><span class="line">    val data: LiveData&lt;String&gt;</span><br><span class="line">        get() = _data</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        _data.value = &quot;Hello, world!&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>EndFragment</code>跟<code>StartFragment</code>如出一辙，没什么可看的，这个 demo 就看完了，唯一疑问就是这种使用 xml 的跳转方式要如何实现数据传递</p>
<p>于是接着看<a href="https://developer.android.google.cn/jetpack/docs/guide" target="_blank" rel="noopener">下一篇</a> | <a href="https://github.com/Android-Jetpack-Chinese-Translation/android-jetpack-chinese-translation/blob/3418494087ed20ec2b3aeb578c90be1f281170e4/ANDROID_JETPACK/B_Get_started/2_Guide_to_app_architecture.md" target="_blank" rel="noopener">译文</a>，里边所说道的 <code>单一数据源</code>真的让我学到很多。最重要的是我发现一个好东西叫做<code>LiveData</code></p>
<blockquote>
<p><a href="https://github.com/Android-Jetpack-Chinese-Translation/android-jetpack-chinese-translation/blob/master/DOCS/B_Guides/3_Core_topics/3_2_Architecture_Components/3_2_5_LiveData.md" target="_blank" rel="noopener"><strong>LiveData</strong></a> 是可观察数据（observable data）的容器，它允许您应用中的组件观察 LiveData 对象的变化，而毋须创建对其的显式强依赖。LiveData 还会根据您的应用组件（如：activity、fragment、服务，等等）的生命周期状态，采取恰当的措施防止内存泄漏。LiveData 非常暖心的一点是：它洞悉组件的生命周期，因而能在引用（references）不再有用时自动清理掉它们。每当用户数据被更新的时候，<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/Observer#onChanged(T" target="_blank" rel="noopener"><code>onChanged</code></a>) 回调函数都会被触发，从而更新 UI。</p>
</blockquote>
<p>也就是 <code>StartFragment</code>中这样的写法实际上可以保证 <code>data</code> 变化时 TextView 中的内容也会跟着更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">viewModel.data.observe(this, Observer &#123; data -&gt;</span><br><span class="line">      // Set the text exposed by the LiveData</span><br><span class="line">      view?.findViewById&lt;TextView&gt;(R.id.text)?.text = data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>这个很像 Rxjava，但比 Rxjava 多出的特性是，LiveData 会自己管理生命周期。我不禁想到昨天看 iosched 中的使用方法，里边好多的逻辑处理的触发机制都是这样的，而这样一套机制，是一个叫做 <a href="https://developer.android.google.cn/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a> 的 package中的东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">open class OnboardingCompleteActionUseCase @Inject constructor(</span><br><span class="line">    private val preferenceStorage: PreferenceStorage</span><br><span class="line">) : UseCase&lt;Boolean, Unit&gt;() &#123;</span><br><span class="line">    override fun execute(completed: Boolean) &#123;</span><br><span class="line">        preferenceStorage.onboardingCompleted = completed</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onboardingViewModel.navigateToMainActivity.observe(this, EventObserver &#123;</span><br><span class="line">            requireActivity().run &#123;</span><br><span class="line">                startActivity(Intent(this, MainActivity::class.java))</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>LiveData 看起来很有用途，而 Navigation 就很迷了，采取 xml 方式看不出有什么优势而且我还不知道它要如何传递数据。还有关于 <code>androidx</code>,<code>Android Architecture Components</code>,<code>Jetpack</code>这几个概念，它们的关系是 <code>Jetpack</code> 包含 <code>Android Architecture Components</code>,<code>Jetpack</code> 包含<code>androidx</code></p>
<p>参考：[Jetpack 官网] (<a href="https://developer.android.com/jetpack/" target="_blank" rel="noopener">https://developer.android.com/jetpack/</a>) | <a href="https://developer.android.com/topic/libraries/architecture/" target="_blank" rel="noopener">Android Architecture Components 官网</a> |<a href="https://developer.android.com/jetpack/androidx/" target="_blank" rel="noopener">AndroidX 官网</a></p>
<blockquote>
<p>Android architecture components are part of <a href="https://developer.android.com/jetpack" target="_blank" rel="noopener">Android Jetpack</a>. </p>
<p>Jetpack comprises the <a href="https://developer.android.com/jetpack/androidx" target="_blank" rel="noopener">androidx.*</a> package libraries, unbundled from the platform APIs.</p>
<p>AndroidX is the open-source project that the Android team uses to develop, test, package, version and release libraries within <a href="https://developer.android.com/jetpack" target="_blank" rel="noopener">Jetpack</a>.</p>
</blockquote>
<h2 id="第三天-2018-10-17"><a href="#第三天-2018-10-17" class="headerlink" title="第三天(2018/10/17)"></a>第三天(2018/10/17)</h2><p>今天的方向是调研宏观架构，而不是具体的框架了。已知有 <code>MVP</code>、<code>MVVM</code>、<code>Clean</code>这三种，不考虑<code>MVC</code>。我是不太熟悉 <code>MVVM</code> 的，看介绍说<code>MVVM</code>比<code>MVP</code>多出了数据绑定，<code>vue</code>就是使用<code>MVVM</code>架构的，这样理解起来就容易了，虽然我没有在 Android 开发中用过 <code>MMVM</code>，但是我有偷偷用过一点 <code>vue</code>。那么我第一天看的 <code>iosched</code>，实际上就是一种 <code>MVVM</code> 的实践，我曾一度认为那是 <code>MVP</code> 。而第二天看到的 <code>Jetpack</code>中的 <code>LiveData</code>，就是数据绑定的具体实现。Google 关键字<code>Android 数据绑定</code>,搜出来的全部都是 Google 官方的 <code>DataBinding</code>框架，但是<code>DataBinding</code>是和 xml 结合使用的，<code>LiveData</code>是在 Java 代码层实现绑定的，后者显然更加灵活。而 <code>Clean</code>，我是真的一点都不知道 <code>Clean</code> 是怎样的架构，研究了一下是四层单向依赖的独立分层，这样确实是降低耦合了，但是感觉写起来要创建好多类好复杂好费劲</p>
<p>我又搜到一个<a href="https://proandroiddev.com/mvc-mvp-mvvm-clean-viper-redux-mvi-prnsaaspfruicc-building-abstractions-for-the-sake-of-building-18459ab89386" target="_blank" rel="noopener">介绍 Android 架构</a>的英文文章，我真是越来越不懂了，居然还有叫做 <code>MVI</code>(Model-View-Intent),<code>VIPER</code>(View Interactor Presenter Entity Routing)的东西，而且 <code>Redux</code>和 <code>FLUX</code> 什么的不本应该是前端的东西吗？我怎么没见到哪个 Android 原生 App 说是用 <code>Redux</code> 架构的。但是写到最后，他推荐的还是 Google 那套 MVVM。翻到最后还是这么写的：<code>The current recommendation: Google’s Android Architecture Components — LiveData (and ViewModel)</code></p>
<blockquote>
<p>来源：<a href="https://hackernoon.com/lessons-learned-implementing-redux-on-android-cba1bed40c41" target="_blank" rel="noopener">Lessons Learned Implementing Redux on Android</a></p>
<p>When a lot of people think of the Redux architecture they think of the web. This isn’t really surprising because it originated and gained a lot of popularity there. At its core, it’s a simple application architecture that describes a system of organizing and manipulating state. This means that it can be applied to any kind of application development including mobile.</p>
</blockquote>
<p>那么还是手动实践一下 Jetpack 吧</p>
<h2 id="第四天-2018-10-18"><a href="#第四天-2018-10-18" class="headerlink" title="第四天(2018/10/18)"></a>第四天(2018/10/18)</h2><h3 id="简述-2"><a href="#简述-2" class="headerlink" title="简述"></a>简述</h3><p>昨天已经用 Jetpack 做了个简单的 Demo，但我嫌这个 Demo 太简单了，它相当于没有 Model 层，于是今天打算把整个流程都走一遍，实现一个这样的场景：从网络获取列表页并实现下拉加载更多。这下就涉及到 Model 层的数据获取以及缓存的部分了。而 Model 层的数据，在 Jetpack 下都是 LiveData，它们对此也有一个 ORM 框架 叫做 <a href="https://developer.android.com/training/data-storage/room/" target="_blank" rel="noopener">Room</a>。据说这个框架本身就支持了 LiveData</p>
<h3 id="Room-框架"><a href="#Room-框架" class="headerlink" title="Room 框架"></a>Room 框架</h3><p>然后我发现了 <a href="https://codelabs.developers.google.com/" target="_blank" rel="noopener">Google Codelabs</a>，一个可以直接下载 Demo 学习的 Google 官方教程网站，上面有关于结合 Jetpack 讲的 <a href="https://codelabs.developers.google.com/codelabs/android-room-with-a-view-kotlin/index.html" target="_blank" rel="noopener">教程</a>，于是借此了解了一下 Room</p>
<p>查询操作貌似必须使用 SQL 语句，这点不太友好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface WordDao &#123;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class="line">    fun getAllWords(): List&lt;Word&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>insert，update，delete可以直接使用标签，也可以使用 SQL 语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface WordDao &#123;</span><br><span class="line"></span><br><span class="line">    @Insert</span><br><span class="line">    fun insert(word: Word)</span><br><span class="line"></span><br><span class="line">    @Update</span><br><span class="line">    fun update(word: Word)</span><br><span class="line">    </span><br><span class="line">    @Delete</span><br><span class="line">    fun delete(word: Word)</span><br><span class="line">    </span><br><span class="line">    @Query(&quot;DELETE FROM word_table&quot;)</span><br><span class="line">    fun deleteAll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以直接查询出 LiveData，这是 Room 独有的特点了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Dao</span><br><span class="line">interface WordDao &#123;</span><br><span class="line"></span><br><span class="line">    @Query(&quot;SELECT * from word_table ORDER BY word ASC&quot;)</span><br><span class="line">   	fun getAllWords(): LiveData&lt;List&lt;Word&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着我看到一篇对比 ORM 框架的文章，发现 ROOM 的性能相对而言并不是很好，也不支持加密，但是优点在于轻量。只占包体积的 50kb，方法数 300 左右。参考文章：<a href="https://juejin.im/entry/59ca6db55188257a125d85b9" target="_blank" rel="noopener">Room，Realm, ObjectBox 你选择哪个？</a>(下面图表的纵轴单位我猜是一种速度单位？因为文章的结论是 ObjectBox 性能最优)</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2017/9/26/23d6420c87d5f7edeafc1ea28ad11b6a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2017/9/26/bd56e25dd49bd435f362f2ce4e154ea5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2017/9/26/f30d09f9cd370252bc93eef5ae94e6e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2017/9/26/fb77688ba420944b34e82b0b6ef20a07?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2017/9/26/857316692be156e8bd2d0779fbdd9847?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://user-gold-cdn.xitu.io/2017/9/26/ada08d38bad75868981d15d007a7c9fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>ObjectBox 貌似真的有点自信有点膨胀，他们甚至有一个这样的<a href="https://github.com/objectbox/objectbox-performance" target="_blank" rel="noopener">开源项目</a>，专门用来把自家 ORM 和其他产品做性能对比并生成图表</p>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2018-10-18T03:51:00.043Z" itemprop="dateUpdated">2018-10-18 11:51:00</time>
</span><br>


        
        转载请注明出处，虽然不会有人转载的说：<a href="/2018/10/16/现有Android框架研究/" target="_blank" rel="external">http://blog.valorachen.club/2018/10/16/现有Android框架研究/</a>
        
    </div>
    <footer>
        <a href="http://blog.valorachen.club">
            <img src="/img/avatar.png" alt="ViVi">
            ViVi
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/&title=《现有Android框架研究》 — ViVi's craft&pic=http://blog.valorachen.club/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/&title=《现有Android框架研究》 — ViVi's craft&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.valorachen.club/2018/10/16/现有Android框架研究/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《现有Android框架研究》 — ViVi's craft&url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/&via=http://blog.valorachen.club" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/07/07/Github-Issues-API/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">网易云音乐API Part1(登录，用户，歌单)</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "EwUx7kp4hDkqF3CsL5B6QGS1-gzGzoHsz",
            appKey: "1tccniD7zvLprgUME5qQiIH1",
            avatar: "mm",
            placeholder: "Say something if you want to",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->




</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>ViVi &copy; 2015 - 2018</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/&title=《现有Android框架研究》 — ViVi's craft&pic=http://blog.valorachen.club/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/&title=《现有Android框架研究》 — ViVi's craft&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.valorachen.club/2018/10/16/现有Android框架研究/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《现有Android框架研究》 — ViVi's craft&url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/&via=http://blog.valorachen.club" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.valorachen.club/2018/10/16/现有Android框架研究/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACtklEQVR42u3aQW7kMAwEwPz/09nrLrL2dFOS4QDlk5FMLNUEEGmSX1/x9R1c95/8+7f39z+fc/WZbRceHh7e1q3fL5Yjf654j7l/TrJnPDw8vNO8qxP16j4nXS4cBIA8kFz+HA8PD+8FvCRrzf+qfT4eHh7eb+QlASPZXFuAwMPDw3sb75nya/vVtKUQPDw8vGd4eRfpPfdH+nt4eHh4mwYC8gM3T5STYLBht3h4eHjHDsL1reeF3STwrAxd4eHh4T3Dyzc6GxFox7PyQ39brRoPDw8v5uVbb8PAbJigHUco6tN4eHh4m3htg3+22KzR1TbSPiDx8PDwNvHytHi9aLtSpEhCVB338PDw8Ea89jjON5ogkyM+D1T1TBkeHh7eiDcrDay0r2aJe7viP2VcPDw8vK28vUd/ki6vB4ykcFx39vDw8PBiXvFKX15t8XdWzvigwMPDwzvGWym8zlLtPCS0rTU8PDy853lJwynK0+NQkV91IMHDw8M7xssT1pVibh4SonR5VsDFw8PD28SbIduSRFvSXUnN/5NS4+Hh4W3lJcu3o1HtE9p1oy8dDw8P7wAvKoaWb/f5M1fWLcrNeHh4eMd4K2NSKwNSs0ErPDw8vPfw2jQ6b5WtDHW1LbG6y4eHh4c34s0emhzceWCYFSM+7AEPDw/vGK89vvPS7UoBIgk/RVTBw8PDO8CbFWTz8sSstNG+AODh4eE9w5s1unaVKmZFiqjygIeHh7eV911eLTgJMLPyRxRa8PDw8A7wZi2oXanwiYR+2GbDw8PDK3ntOFTel8+/pvUU/PIfgIeHh3eMl7e41reVbHplPAsPDw/vbbyVwzrfdJtebwsMeHh4eId5bQhpCxOzcS48PDy8Z3grzaeVdtT9WrPBBTw8PLzTvDbB3dVn2zVutWFgCw8PDy9d5Q9RhnOoDvJOQAAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
